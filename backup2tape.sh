#! /bin/bash

# TODO
# (test) Exclude per Module
# (test) Include per Module
# (test) Read Only Tapes system
# (test) Check for started tape id and last tape id
# Change data to current dir (git)
# (test) Check for root id
# (test) Test Module exists

# Lazy Colors
C_NONE="\033[0m"
C_RED="\033[0;31m"
C_BLUE="\033[0;34m"
C_GREEN="\033[0;32m"
C_YELLOW="\033[1;33m"
C_CYAN="\033[0;36m"
C_ORANGE="\033[0;33m"

# Fancy Line printing.
function printLine {
  echo -e "  ├ $*"
}

function printHeader {
  echo -e "  ┌──══ ${C_GREEN}$*${C_NONE}"
}

function printEnd {
  echo -e "  └──── "
}

# Tell the people who we are :-)
printHeader "backup2tape"

#  Config. Dont touch these, override with config file
MODULE_BASE="/media"
BASE="./data"
TAPE_DEVICE="/dev/nst0"

# Handle overrides, if present.
if [ -e "config" ] ; then
  printLine "Local config round, loading."
  . config
fi

##
#
# bash argument pasring START
#
##

die()
{
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}


begins_with_short_option()
{
  local first_option all_short_options='d'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_device="${TAPE_DEVICE}"


print_help()
{
  printf 'Usage: %s [-d|--device <arg>] <module> \n' "$0"
  printf '\t%s\n' "<module>: what module to back up"
  printf '\t%s\n' "-d, --device: specify a tape device (default: '${TAPE_DEVICE}')"
}


parse_commandline()
{
  _positionals_count=0
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -d|--device)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_device="$2"
        shift
        ;;
      --device=*)
        _arg_device="${_key##--device=}"
        ;;
      -d*)
        _arg_device="${_key##-d}"
        ;;
      *)
        _last_positional="$1"
        _positionals+=("$_last_positional")
        _positionals_count=$((_positionals_count + 1))
        ;;
    esac
    shift
  done
}


handle_passed_args_count()
{
  local _required_args_string="'module'"
  test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
  test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
  local _positional_name _shift_for=$1
  _positional_names="_arg_module"

  shift "$_shift_for"
  for _positional_name in ${_positional_names}
  do
    test $# -gt 0 || break
    eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
    shift
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


##
#
# bash argument end
#
##

# Check for root rights
if [ "$(whoani)" != 'root' ] ; then
  printLine "Need superuser rights."
  printEnd
  exit 1
fi

#
# Set some variables
#
# The module (directory) to back up.
MODULE=${_arg_module}
# Load the serial number from the currently loaded tape.
TAPE=$(sudo sg_read_attr -q -f 0x0401 /dev/nst0 | awk -F 'Medium serial number: ' ' { print $2 } ' | awk ' { print $1 }')

# Show a summary of things found.
printLine "Device : ${TAPE_DEVICE}"
printLine "Tape   : ${TAPE}"
printLine "Module : ${MODULE}"

# Check if we have a tape inserted.
if [ -c "${TAPE_DEVICE}" ] ; then
  printLine "Tape Device ${TAPE_DEVICE} found."
else
  printLine "Tape Device ${TAPE_DEVICE} not found!"
  printEnd
  exit 2
fi

# Check if there is a tape inserted at all. If not, die.
if [ "$(mt -f /dev/nst0 status | grep -c 'DR_OPEN IM_REP_EN')" == '1' ] ; then
  printLine "No tape is inserted, aborting."
  printEnd
  exit 0
fi

# Check if the inserted tape is marked as read-only in our DB.
if [ "$(grep -c \""${TAPE}"\" \"${BASE}/read-only.tapes\")" != '0' ] ; then
  printLine "Tape ${TAPE} is marked as full, can\'t use!"
  printEnd
  exit 1
fi

# Get current tape position.
TAPE_POS=$(mt -f ${TAPE_DEVICE} status | grep 'File number=' | awk -F'File number=' ' { print $2 } ' | awk -F',' ' { print $1 } ')

# Check if the tape is known to us.
if [ ! -e "${BASE}/${TAPE}.track" ] ; then
  # Fresh tape.
  printLine "New tape, starting from BOT."
  TRACK='0'
else
  # Known track.
  CUR_POS=$(cat "${BASE}/${TAPE}.track")
  # let CUR_POS=CUR_POS+1
  #let fsf_count=CUR_POS-TAPE_POS
  (( fsf_count=CUR_POS-TAPE_POS )) || true
  #printLine "Known tape, continuing at ${CUR_POS}, currently at ${TAPE_POS}, need to forward ${fsf_count} marks!"

  # Check if we need to move the tape.
  if [ "${TAPE_POS}" != "${CUR_POS}" ] ;then
    printLine "Known tape, continuing at ${CUR_POS}, currently at ${TAPE_POS}, need to forward ${fsf_count} marks!"
    mt -f "${TAPE_DEVICE}" fsf "${fsf_count}"

    TAPE_POS=$(mt -f ${TAPE_DEVICE} status | grep 'File number=' | awk -F'File number=' ' { print $2 } ' | awk -F',' ' { print $1 } ')
    printLine "Tape is now at position ${TAPE_POS}."
  else
    printLine "Known tape, continuing at ${CUR_POS}, currently at ${TAPE_POS}, no spooling required."
  fi
  TRACK="${CUR_POS}"
fi

# Accemble the options for tar
OPTIONS="--exclude-backups --listed-incremental=${BASE}/${MODULE}.diff -M --index-file=${BASE}/${MODULE}-${TAPE}-${TRACK}.idx -cvf ${TAPE_DEVICE}"

# Free space on tape.
# sudo sg_read_attr /dev/nst0 |  grep 'Remaining capacity in partition' | awk ' { print $6 } '

# Check that the module exists in the mount dir.
if [ ! -d "${MODULE_BASE}/${MODULE}" ] ; then
  printLine "module ${MODULE_BASE}/${MODULE} not found."
  printEnd
  exit 1
fi

#if [ "${MODULE}" == "rsnapshot" ] ; then
#  for p in 'nextcloud/var/lib/nextcloud/christian/files' 'nextcloud/var/lib/nextcloud/miriam/files' ; do
#    MODULES="${MODULES} ${MODULE}/daily.0/$p"
#  #done
#  MODULE=${MODULES}
#fi

# Assemble Includes, if any
if [ -e "${BASE}/includes/${MODULE}" ] ; then
  printLine "Include directive for ${MODULE} found."
  grep -v '^ *#' < "${BASE}/includes/${MODULE}" | while IFS= read -r line ; do
    includes=$includes "${MODULE_BASE}/${MODULE}/${line}"
  done
fi

# Assemble Excludes, if any
if [ -e "${BASE}/excludes/${MODULE}" ] ; then
  printLine "Exclude directive for ${MODULE} found."
  #for i in $(cat "${BASE}/excludes/${MODULE}") ; do
  #  excludes=$excludes "--${MODULE_BASE}/${MODULE}/$i"
  #done
  excludes="--exclude-ignore=\"${BASE}/includes/${MODULE}\""
fi

# Back up the whole module or the includes ONLY.
if [ "${includes}" != "" ] ; then
  backup_targets=${includes}
else
  backup_targets=${MODULE}
fi

# Do the actual backup.
cd "${MODULE_BASE}" || exit 2
tar "${OPTIONS}" "${excludes}" "${includes}" 1>/dev/null
printLine "Dump OK."

# Backup done! Wohoo!
CUR_POS=$(mt -f ${TAPE_DEVICE} status | grep 'File number=' | awk -F'File number=' ' { print $2 } ' | awk -F',' ' { print $1 } ') || exit 2

# Check if we are on the same tape we started, or not.
CURRENT_TAPE=$(sudo sg_read_attr -q -f 0x0401 /dev/nst0 | awk -F 'Medium serial number: ' ' { print $2 } ' | awk ' { print $1 }')

if [ "${CURRENT_TAPE}" == "${TAPE}" ]; then
  # Same Tape.
  echo "${CUR_POS}" > ${BASE}/"${TAPE}".track
else
  # New Tape.
  printLine "Marking Tape ID ${TAPE} as read-only."
  echo "${TAPE}" > "${BASE}/read-only.tapes"
  rm -f "${BASE}/${TAPE}.track"

  printLine "Setting Track ID to ${CUR_POS} for ID ${CURRENT_TAPE}."
  echo "${CUR_POS}" > ${BASE}/"${CURRENT_TAPE}".track
  if [ ! -e "${BASE}/${MODULE}-${CURRENT_TAPE}-${TRACK}.idx" ] ; then
    ln -s "${BASE}/${MODULE}-${TAPE}-${TRACK}.idx" "${BASE}/${MODULE}-${CURRENT_TAPE}-${TRACK}.idx"
  fi
fi

printEnd
